-- StandBot (WaveAI) â€” Main Script
-- Repo: https://github.com/kryvendev/standbot

local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local TextChatService = game:GetService("TextChatService")
local RunService = game:GetService("RunService")
local LP = Players.LocalPlayer

-- Owner and settings come from getgenv()
local OwnerId = getgenv().OwnerId or 0
local BotSettings = getgenv().BotSettings or {}

local Whitelist = { [OwnerId] = true }
local ChatLogsVisible = false
local FollowingConnection = nil

-- ChatLogs GUI
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "ChatLogGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = game:GetService("CoreGui")

local Frame = Instance.new("Frame", ScreenGui)
Frame.Size = UDim2.new(0.4, 0, 0.4, 0)
Frame.Position = UDim2.new(0.3, 0, 0.3, 0)
Frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
Frame.BackgroundTransparency = 0.2
Frame.Active = true
Frame.Draggable = true
Frame.Visible = false

local UICorner = Instance.new("UICorner", Frame)
UICorner.CornerRadius = UDim.new(0, 8)

local Scrolling = Instance.new("ScrollingFrame", Frame)
Scrolling.Size = UDim2.new(1, -10, 1, -10)
Scrolling.Position = UDim2.new(0, 5, 0, 5)
Scrolling.CanvasSize = UDim2.new(0, 0, 0, 0)
Scrolling.BackgroundTransparency = 1
Scrolling.ScrollBarThickness = 6
Scrolling.AutomaticCanvasSize = Enum.AutomaticSize.Y

local UIListLayout = Instance.new("UIListLayout", Scrolling)
UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
UIListLayout.Padding = UDim.new(0, 2)

-- Utility
local function addChatLine(text, isOwner)
    local lbl = Instance.new("TextLabel")
    lbl.Parent = Scrolling
    lbl.Size = UDim2.new(1, -5, 0, 20)
    lbl.BackgroundTransparency = 1
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    lbl.Font = Enum.Font.SourceSansSemibold
    lbl.TextColor3 = isOwner and Color3.fromRGB(255, 215, 0) or Color3.new(1,1,1)
    lbl.TextSize = 16
    lbl.Text = text
    task.wait()
    Scrolling.CanvasPosition = Vector2.new(0, math.huge)
end

local function sendChatMessage(msg)
    local channel = TextChatService.TextChannels:FindFirstChild("RBXGeneral")
    if channel then channel:SendAsync(msg) end
end

local function getHumanoid()
    local char = LP.Character or LP.CharacterAdded:Wait()
    return char:FindFirstChildOfClass("Humanoid")
end

local function disableAnimations(char)
    if not BotSettings.DisableAnimations then return end
    local animate = char:FindFirstChild("Animate")
    if animate then animate:Destroy() end
    for _, anim in pairs(char:GetDescendants()) do
        if anim:IsA("Animator") then
            for _, track in pairs(anim:GetPlayingAnimationTracks()) do
                track:Stop()
            end
        end
    end
end

local function equipToolByName(name)
    local hum = getHumanoid()
    if hum then
        local tool = LP.Backpack:FindFirstChild(name)
        if tool then hum:EquipTool(tool) end
    end
end

local function unequipAll()
    local hum = getHumanoid()
    if hum then hum:UnequipTools() end
end

local function summonTo(player)
    if not player or not player.Character then return end
    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
    if hrp then (LP.Character or LP.CharacterAdded:Wait()):MoveTo(hrp.Position) end
end

local function rejoin()
    TeleportService:Teleport(game.PlaceId, LP)
end

local function findPlayerByName(query)
    query = query:lower():gsub("^%s+", ""):gsub("%s+$", "")
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Name:lower():find(query, 1, true) or (plr.DisplayName and plr.DisplayName:lower():find(query, 1, true)) then
            return plr
        end
    end
end

local function forceResetAndReturn()
    local hum = getHumanoid()
    if hum then hum.Health = 0 end
    LP.CharacterAdded:Wait()
    local owner = Players:GetPlayerByUserId(OwnerId)
    if owner and owner.Character and owner.Character:FindFirstChild("HumanoidRootPart") then
        local hrp = (LP.Character or LP.CharacterAdded:Wait()):WaitForChild("HumanoidRootPart")
        hrp.CFrame = owner.Character.HumanoidRootPart.CFrame + Vector3.new(0, 5, 0)
    end
end

-- Auto strafe
local function autoStrafe(target)
    local char = LP.Character or LP.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hrp or not hum then return end
    disableAnimations(char)

    local startTime = tick()
    local connection
    connection = RunService.Heartbeat:Connect(function()
        if not target or not target.Parent then connection:Disconnect() return end
        local targetChar = target.Character
        local targetHum = targetChar and targetChar:FindFirstChildOfClass("Humanoid")
        local targetHRP = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
        if not targetChar or not targetHRP or not targetHum then return end
        if targetHum.Health <= 0 then connection:Disconnect() return end
        if tick() - startTime >= BotSettings.StrafeDuration then connection:Disconnect() return end

        if hum.Health / hum.MaxHealth * 100 <= BotSettings.LowHealthThreshold then
            connection:Disconnect()
            forceResetAndReturn()
            return
        end

        local angle = tick() * BotSettings.StrafeSpeed
        local offset = Vector3.new(math.cos(angle), 0, math.sin(angle)) * BotSettings.StrafeDistance
        local targetCFrame = CFrame.new(targetHRP.Position + offset, targetHRP.Position)
        hrp.CFrame = hrp.CFrame:Lerp(targetCFrame, 0.25)
        hum.Jump = true
    end)
end

-- Follow system (walk offset)
local function followPlayer(target, mode)
    if FollowingConnection then FollowingConnection:Disconnect() end
    local char = LP.Character or LP.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = getHumanoid()
    disableAnimations(char)

    local offset
    if mode == "left" then
        offset = Vector3.new(-5, 0, 0)
    elseif mode == "right" then
        offset = Vector3.new(5, 0, 0)
    else
        offset = Vector3.new(0, 0, -5) -- default behind
    end

    FollowingConnection = RunService.Heartbeat:Connect(function()
        if not target or not target.Character then return end
        local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
        local targetHum = target.Character:FindFirstChildOfClass("Humanoid")
        if not targetHRP or not targetHum then return end

        if hum.Health / hum.MaxHealth * 100 <= BotSettings.LowHealthThreshold then
            FollowingConnection:Disconnect()
            forceResetAndReturn()
            return
        end

        local dir = targetHRP.CFrame.LookVector
        local right = targetHRP.CFrame.RightVector
        local pos = targetHRP.Position 
            + dir * offset.Z 
            + right * offset.X 
            + Vector3.new(0, offset.Y, 0)

        hum:MoveTo(pos)
        hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + dir) -- face same direction
    end)
end

local function unfollow()
    if FollowingConnection then
        FollowingConnection:Disconnect()
        FollowingConnection = nil
    end
end

-- Chat listener
TextChatService.OnIncomingMessage = function(message)
    local src = message.TextSource
    local sender = src and Players:GetPlayerByUserId(src.UserId)
    local msgText = message.Text or ""
    if sender then
        addChatLine(sender.Name .. ": " .. msgText, src.UserId == OwnerId)
    else
        addChatLine("[System]: " .. msgText, false)
    end
    if not src then return end

    local isOwner = src.UserId == OwnerId
    local allowed = Whitelist[src.UserId]
    local txt = msgText:lower()

    -- Owner-only
    if isOwner and txt:sub(1,10) == "whitelist!" then
        local query = msgText:sub(11):gsub("^%s+", "")
        local target = findPlayerByName(query)
        if target then Whitelist[target.UserId] = true sendChatMessage("Whitelisted " .. target.Name)
        else sendChatMessage("Invalid username") end
        return
    elseif isOwner and txt:sub(1,12) == "unwhitelist!" then
        local query = msgText:sub(13):gsub("^%s+", "")
        local target = findPlayerByName(query)
        if target and target.UserId ~= OwnerId then
            Whitelist[target.UserId] = nil
            sendChatMessage("Unwhitelisted " .. target.Name)
        else sendChatMessage("Invalid username") end
        return
    elseif isOwner and txt == "checkwl!" then
        local names = {}
        for uid, _ in pairs(Whitelist) do
            local plr = Players:GetPlayerByUserId(uid)
            table.insert(names, plr and plr.Name or "UserId:" .. tostring(uid))
        end
        sendChatMessage("Whitelisted: " .. table.concat(names, ", "))
        return
    elseif isOwner and txt == "rj!" then
        rejoin() return
    end

    if not allowed then return end

    -- Normal commands
    if txt == "wallet!" then
        equipToolByName("[Wallet]")
    elseif txt == "unwallet!" then
        unequipAll()
    elseif txt == "summon!" or txt == "s" then
        summonTo(sender)
    elseif txt:sub(1,5) == "auto!" then
        local query = msgText:sub(7)
        local target = findPlayerByName(query)
        if target then autoStrafe(target) end
    elseif txt:sub(1,7) == "follow!" then
        local arg = msgText:sub(9):lower()
        if arg == "left" then
            followPlayer(sender, "left")
        elseif arg == "right" then
            followPlayer(sender, "right")
        else
            followPlayer(sender, "behind")
        end
    elseif txt == "unfollow!" then
        unfollow()
    elseif txt == "chatlogs!" then
        ChatLogsVisible = not ChatLogsVisible
        Frame.Visible = ChatLogsVisible
    elseif txt == "cmds!" then
        sendChatMessage("Commands: wallet!, unwallet!, summon!/s, auto! <user>, follow! [behind/left/right], unfollow!, chatlogs!, rj! (owner), whitelist!, unwhitelist!, checkwl!")
    end
end
